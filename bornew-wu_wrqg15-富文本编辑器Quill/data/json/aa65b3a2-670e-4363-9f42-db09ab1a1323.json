{
  "body_html": "<!doctype html><a name=\"概念介绍\"></a><h2 id=\"8fb4ce69\">概念介绍</h2><p><br /></p><p>Parchment 是 Quill 的文档模型。是一个和 DOM 树对应的平行树结构，给内容编辑器 Quill 提供有用的功能。</p><p><br /></p><p>一个 Parchment 树是由 Blots 构成。Blot 是一个 DOM 节点的对应物。Blots 可以提供结构，格式化，或内容。Attributor 可以提供轻量级的格式化信息。</p><p><br /></p><p>Parchment tree 是 DOM tree 的对应，二者关系紧密。</p><p><br /></p><a name=\"官方示例\"></a><h2 id=\"3b462e1d\">官方示例</h2><p><br /></p><p>LinkBlot</p><p><br /></p><pre><code>import Parchment from 'parchment';\n\nclass LinkBlot extends Parchment.Inline {\n  static create(url) {\n    let node = super.create();\n    node.setAttribute('href', url);\n    node.setAttribute('target', '_blank');\n    node.setAttribute('title', node.textContent);\n    return node;\n  }\n\n  static formats(domNode) {\n    return domNode.getAttribute('href') || true;\n  }\n\n  format(name, value) {\n    if (name === 'link' &amp;&amp; value) {\n      this.domNode.setAttribute('href', value);\n    } else {\n      super.format(name, value);\n    }\n  }\n\n  formats() {\n    let formats = super.formats();\n    formats['link'] = LinkBlot.formats(this.domNode);\n    return formats;\n  }\n}\nLinkBlot.blotName = 'link';\nLinkBlot.tagName = 'A';\n\nParchment.register(LinkBlot);</code></pre><p><br /></p><a name=\"常见问题\"></a><h2 id=\"50d52dd9\">常见问题</h2><p><br /></p><a name=\"富文本编辑器为什么需要自己的一套文档模型？\"></a><h3 id=\"c14e92d3\">富文本编辑器为什么需要自己的一套文档模型？</h3><p><br /></p><p>为什么必要？<br />\n为了提供一致的编辑体验，你需要一致的数据和可预测的行为。但是 DOM 在这两方面都不完美。所以现代的编辑器通过管理自己的文档模型来表示内容。</p><p><br /></p><p>它的价值？<br />\n提供一致的数据和可预测的行为</p><p><br /></p><a name=\"如何构造出一套文档模型？如何与-DOM-建立关系?\"></a><h3 id=\"6cd6f032\">如何构造出一套文档模型？如何与 DOM 建立关系?</h3><p><br /></p><p>首先需要定义出一套基础抽象节点类型, 一套基础的 Attributor</p><p><br /></p><pre><code>ParentBlot, \nContainerBlot,\nLeafBlot,\nEmbedBlot,\nScrollBlot,\nBlockBlot, \nInlineBlot,\nTextBlot\n\nAttributor\nClassAttributor\nStyleAttributor</code></pre><p><br /></p><p>然后会依赖于这些基础节点类型，来构造出一些实际节点类型。Quill 中定义了一些实际节点</p><p><br /></p><pre><code>BlockBlot =&gt; Block\nEmbedBlot =&gt; BlockEmbed\nEmbedBlot =&gt; Break\nContainerBlot =&gt; Container\nEmbedBlot =&gt; Cursor\nEmbedBlot =&gt; Embed\nInlineBlot =&gt; Inline\nScrollBlot =&gt; Scroll\nTextBlot =&gt; Text</code></pre><p><br /></p><p>如何与 DOM 建立关系?<br />\n新建 Blot 时会调用<code>static create</code>方法创建 dom 节点，并设置<code>blot.domNode = dom</code>。 即建立关系。</p><p><br /></p><a name=\"源码分析\"></a><h2 id=\"8ce750bd\">源码分析</h2><p><br /></p><a name=\"基础设计\"></a><h3 id=\"52c127d1\">基础设计</h3><p><br /></p><p>目录结构</p><p><br /></p><pre><code>- src\n - attributor\n - attributor.ts\n - class.ts\n - store.ts\n - style.ts\n - blot\n - abstract\n - blot.ts\n - container.ts\n - format.ts\n - leaf.ts\n - shadow.ts\n - block.ts\n - embed.ts\n - inline.ts\n - scroll.ts\n - text.ts\n - collection\n - linked-list.ts\n - linked.node.ts\n - parchment.ts\n - registry.ts</code></pre><p><br /></p><a name=\"类图完整版\"></a><h4 id=\"d39cbb84\">类图完整版</h4><p><br /></p><p><img src=\"https://segmentfault.com/img/bVbsmBq?w=2059&amp;h=3627#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"类图简易版\"></a><h4 id=\"231aa641\">类图简易版</h4><p><br /></p><p><img src=\"https://segmentfault.com/img/bVbsmBu?w=1215&amp;h=1130#alt=\" style=\"max-width: 600px;\" /></p><p><br /></p><a name=\"在-parchment.ts-中对外导出的有四类东西。\"></a><h4 id=\"8a932be9\">在 parchment.ts 中对外导出的有四类东西。</h4><p><br /></p><ul><li>\n节点 Blot\n</li></ul><ul data-lake-indent=\"1\"><li>ParentBlot 【父级节点】能对子节点进行增，删，改，移动，查</li></ul><ul data-lake-indent=\"1\"><li>ContainerBlot 【容器节点】</li></ul><ul data-lake-indent=\"1\"><li>LeafBlot 【叶节点】</li></ul><ul data-lake-indent=\"1\"><li>EmbedBlot 嵌入式节点 【可格式化的叶节点】</li></ul><ul data-lake-indent=\"1\"><li>ScrollBlot root【文档的根节点，不可格式化】</li></ul><ul data-lake-indent=\"1\"><li>BlockBlot 块级 【可格式化的父级节点】</li></ul><ul data-lake-indent=\"1\"><li>InlineBlot 内联 【可格式化的父级节点】</li></ul><ul data-lake-indent=\"1\"><li>TextBlot 文本【叶节点】</li></ul>\n<ul><li>\n属性 Attributor\n</li></ul><ul data-lake-indent=\"1\"><li>Attributor 【一种代表格式的方法】</li></ul><ul data-lake-indent=\"1\"><li>ClassAttributor 【使用 classname 模式来代表格式】</li></ul><ul data-lake-indent=\"1\"><li>StyleAttributor 【使用内联样式来代表格式】</li></ul><ul data-lake-indent=\"1\"><li>AttributorStore 【节点的 attributes 管理器】在 BlockBlot InlineBlot 中使用到了</li></ul>\n<ul><li>\n注册中心\n</li></ul><ul data-lake-indent=\"1\"><li>Registry 【static blots = new WeakMap&lt;Node, Blot&gt;， attributes，classes，tags，types 】</li></ul>\n<ul><li>\n类型常量 Scope\n</li></ul><ul data-lake-indent=\"1\"><li>Scope</li></ul>\n<p><br /></p><a name=\"从一个例子看源码流程\"></a><h3 id=\"357eed70\">从一个例子看源码流程</h3><p><br /></p><pre><code>let Inline = Quill.import('blots/inline');\n\nclass BoldBlot extends Inline { }\nBoldBlot.blotName = 'bold';\nBoldBlot.tagName = 'strong';\n\nclass ItalicBlot extends Inline { }\nItalicBlot.blotName = 'italic';\nItalicBlot.tagName = 'em';\n\nQuill.register(BoldBlot);\nQuill.register(ItalicBlot);\n\nlet quill = new Quill('#editor-container');\n\n$('#bold-button').click(function() {\n  quill.format('bold', true);\n});\n$('#italic-button').click(function() {\n  quill.format('italic', true);\n});</code></pre><p><br /></p><ol start=\"1\"><li>\n依赖于 Quill 提供的 Inline 类，构造了 BoldBlot, ItalicBlot 类，并注册到 Quill, 会注册出 formats/blod, formats/italic（是在 Parchment 导出的 Registry 中注册）\n</li></ol><ol start=\"2\"><li>\n传入 dom id, 构造出一个 Quill 实例 quill。 这里会初始化大量属性，和它内部的模块，注册一些事件，#editor-container 中会插入些个 quill 自己的 dom 结构，prev sibling 会插入一个 div.ql-toolbar。\n\n\n</li></ol><p><br /></p><p>3. 给 toolbar 上的 icon 绑定事件，click 触发时执行 quill 的格式化方法（里面会做一些判断，看是否有 selection, 进行对应的格式化）。</p><p><br /></p><a name=\"quill.format-分两种情况\"></a><h4 id=\"ad525c17\">quill.format 分两种情况</h4><p><br /></p><a name=\"A.-选中部分内容后，执行格式化。代码流程：\"></a><h5 id=\"08e386f6\">A. 选中部分内容后，执行格式化。代码流程：</h5><p><br /></p><pre><code>this.editor.formatText -&gt; [this.scroll.formatAt, this.update(delta)] -&gt; scrollBlot.formatAt -&gt; parent.formatAt -&gt; inline.formatAt -&gt; inline.format(DOM修改)</code></pre><p><br /></p><p><code>quill.format('bold', true)</code>本质上会找到 BoldBlot，然后执行它的 format 方法（格式化选中部分），同步更新 delta, 真实的修改 DOM，给 selection 添加 strong 标签。</p><p><br /></p><p>delta 同步和 DOM 同步是彼此独立的，delta 同步相对简单一些（但会做一些组合优化）</p><p><br /></p><pre><code>const delta = new Delta().retain(index).retain(length, clone(formats));\nreturn this.update(delta);`</code></pre><p><br /></p><a name=\"B.-未选中内容，执行格式化。\"></a><h5 id=\"09b6a4f5\">B. 未选中内容，执行格式化。</h5><p><br /></p><p>未选中内容是对光标进行格式化。 <code>this.selection.format -&gt; this.cursor.format</code>。即会对光标后新写的内容对应格式化。</p><p><br /></p><a name=\"另一个例子\"></a><h3 id=\"631066b4\">另一个例子</h3><p><br /></p><pre><code>class DividerBlot extends BlockEmbed { }\nDividerBlot.blotName = 'divider';\nDividerBlot.tagName = 'hr';\n\n$('#divider-button').click(function() {\n  let range = quill.getSelection(true);\n  quill.insertText(range.index, '\\n', Quill.sources.USER);\n  quill.insertEmbed(range.index + 1, 'divider', true, Quill.sources.USER);\n  quill.setSelection(range.index + 2, Quill.sources.SILENT);\n});</code></pre><p><br /></p><p>insertEmbed 基本流程：<code>quill.insertEmbed -&gt; this.editor.insertEmbed -&gt; [this.scroll.insertAt, this.update(delta)] -&gt; 创建 DOM，插到指定位置</code><br />\n同样的，创建 DOM，更新 delta 都会进行。</p><p><br /></p><a name=\"参考资料\"></a><h2 id=\"35808e79\">参考资料</h2><p><br /></p><p><a href=\"https://github.com/quilljs/parchment/\" target=\"_blank\">https://github.com/quilljs/pa...</a></p><p><br /></p><p><a href=\"https://quilljs.com/guides/cloning-medium-with-parchment/\" target=\"_blank\">https://quilljs.com/guides/cl...</a><br />\n<a href=\"https://segmentfault.com/a/1190000019114222\" target=\"_blank\">https://segmentfault.com/a/1190000019114222</a></p>",
  "slug": 30231305,
  "title": "Quill parchment - SegmentFault 思否"
}