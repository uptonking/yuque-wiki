{
  "body_html": "<!doctype html><div class=\"lake-content-editor-core lake-engine lake-typography-classic\" data-lake-element=\"root\" data-selection-undefined=\"%7B%22path%22%3A%5B%5B30%2C0%5D%2C%5B30%2C0%5D%5D%2C%22active%22%3Atrue%7D\"><h3 data-lake-id=\"49138f9c3d93e65656b823112ce8fb4c\" id=\"BFcBS\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">进程与线程</h3><p data-lake-id=\"896718ca832b796531f2919efc9dbf30\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">用课本的话回答<strong>“进程是资源分配的最小单位，线程是CPU调度的最小单位”</strong></p><p data-lake-id=\"34668878aadba9738d34f252340c5889\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">怎么理解：</p><ul data-lake-id=\"0014a34eec3c5c58fe3455368fa73204\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"213e89a758a5b23358bd002ab58a0a49\"><strong>进程：</strong>当执行一段程序时，会创建一个进程去执行代码，同时会为这个进程分配内存空间。该应用的状态都会保存在该内存空间中，当应用关闭时，该内存空间就会被回收。进程可以启动更多进程去执行任务。由于每个进程间的的内存空间是独立的，不同进程间的数据传输需要接触进程通信管道（IPC）来进行。很多应用都是多进程的结构，避免一个进程卡死后整个程序崩溃。</li><li data-lake-id=\"1feb177b5e56cf98dba29076131659aa\"><strong>线程：</strong>进程可以将一个任务分成更多细小的任务，然后通过创建多个线程，并行执行不同的任务，同一进程下的线程可以直接通信、共享数据。多个线程按一定方式占据 CPU 的时间片以执行任务，是调度过程的参与者</li></ul><div data-card-type=\"block\" data-lake-card=\"hr\"><hr style=\"background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;\"></div><h3 data-lake-id=\"df4fd3b0bdd31f55eecb14f576a7dd36\" id=\"79Ugy\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">进程间通信方式</h3><p data-lake-id=\"52e56e3024cff9566b02c55cc109c58c\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">进程间通信即 IPC，其实现由多种方法</p><h4 data-lake-id=\"cba886b87fd75d32a9cac72c28c6e8d0\" id=\"aHXgK\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 16px; line-height: 24px;\">管道 pipe</h4><p data-lake-id=\"766c28ec153c4371e7468c24af3a17eb\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">管道是一种适合于<strong>父子进程间通信</strong>的方式，可视为一种文件，但只存在于内存中。父进程在fork 子进程之前会创建 IPC 管道并监听它，当真正创建出子进程后，通过环境变量告诉子进程 IPC 管道的文件描述符，子进程启动过程中会根据文件描述符连接已存在的管道，完成父子进程的连接。</p><p data-lake-id=\"2155ca9454472177dc39e8aa2db961c8\" style=\"text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span data-card-type=\"inline\" data-lake-card=\"image\" class=\"lake-card-margin-top lake-card-margin-bottom\"><img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2021/png/670787/1609847354143-156e3b34-3738-44e9-acad-81e8bc7414b7.png\" data-raw-src=\"\" class=\"image lake-drag-image\" alt=\"image.png\" title=\"image.png\" data-height=\"165px\" style=\"visibility: visible; width: 305px;\"></span></p><p data-lake-id=\"604e76f0c0a4306d9c1b1fdf178b96c3\" style=\"text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span>管道可以连接两个地址空间进行数据传输，每个管道会创建两个文件描述符，fd[0] 打开表示读，</span>fd[1] 打开表示写，若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）</p><p data-lake-id=\"2d8655914b3c3b0a4da6faffa5974d97\" style=\"text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span data-card-type=\"inline\" data-lake-card=\"image\" class=\"lake-card-margin-top lake-card-margin-bottom\"><img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2021/png/670787/1609848289275-c69fa278-c413-4fd8-911a-eebfc336ee07.png\" data-raw-src=\"\" class=\"image lake-drag-image\" alt=\"323808-20160311094030069-935122142.png\" title=\"323808-20160311094030069-935122142.png\" data-height=\"186px\" style=\"visibility: visible; width: 555px;\"></span></p><h4 data-lake-id=\"d9af1115b116ffe08a5f827186914502\" id=\"d6U6p\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 16px; line-height: 24px;\">FIFO</h4><p data-lake-id=\"e1d3e62b7ae4c4706a655e2dcedf9469\" style=\"text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">FIFO 是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个 FIFO 都有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中，允许不相关的进程访问同一个 FIFO。因此也成为命名管道。使用 FIFO 通信时，在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。</p><p data-lake-id=\"82f1a404eb4d0e7ca5adafef40331638\" style=\"text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span data-card-type=\"inline\" data-lake-card=\"image\" class=\"lake-card-margin-top lake-card-margin-bottom\"><img data-role=\"image\" src=\"https://cdn.nlark.com/yuque/0/2021/png/670787/1609848595390-4d04651f-ff2d-4593-8fe2-32cfd2df591b.png\" data-raw-src=\"\" class=\"image lake-drag-image\" alt=\"FIFO.png\" title=\"FIFO.png\" data-height=\"249px\" style=\"visibility: visible; width: 281px;\"></span></p><h4 data-lake-id=\"ba7ff67d6275e8004837f1b6aa7c3ca1\" id=\"vusVp\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 16px; line-height: 24px;\">消息队列</h4><p data-lake-id=\"d01df47c252c8c0033053eb787ab2a3c\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">消息队列，是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标识。不同进程将格式化的数据流以消息形式发送给任意进程，该数据会被消息队列接收。对消息队列具有操作权限的进程都可以使用 msgget 完成对消息队列的操作控制。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序</p><h4 data-lake-id=\"21291d566384decaf44e4198f8be738d\" id=\"ng8tU\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 16px; line-height: 24px;\">信号量 + 共享内存</h4><p data-lake-id=\"344b76a087f4fd5648ba546b08fdfe0d\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要借助信号量进行同步。以简单的二元信号量为例，seg 只能为 0 或 1，当进程 A 读取内存时，使信号量减一，seg 变成 0，进程 B 想要访问内存时就会被堵塞，当 A 读取结束，信号量加一，seg 变回1，此时进程 B 恢复执行，开始读取数据。</p><div data-card-type=\"block\" data-lake-card=\"hr\"><hr style=\"background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;\"></div><h3 data-lake-id=\"c387e48e29400afc2b6e6d99ca1ca8a0\" id=\"IrNsP\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">死锁</h3><p data-lake-id=\"55c1da197317bc32e48b08b0f34c0d38\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">死锁是多个进程/线程在运行过程中因争夺资源而造成的一种僵局：线程 A 拥有资源 a，此时需要获取资源 b；线程 B 拥有资源 b，需要获取资源 a，此时 A 锁住了 a，B 锁住了 b，二者共同等待对方释放资源，此时发生死锁</p><p data-lake-id=\"4468c7fb193d8b5c6941e951edc96b91\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>死锁预防</strong></p><ul data-lake-id=\"d0296e8b209b55a3f77522fb451dbc32\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"7ec709a22b2b1fc534147505613d3ccb\"><strong>一次性分配：</strong>运行进程执行前一次性请求所有资源</li><li data-lake-id=\"502709ce59f3000a226bd37c67fe08a8\"><strong>允许资源剥夺：</strong>为任务分配优先级，高优先级进程可抢占低优先级进程资源，需要保存低优先级进程的状态，方便恢复</li><li data-lake-id=\"0bdb9c36148638f8dc450ad0e06fcad6\"><strong>定义资源线性顺序：</strong>已知 Ri&lt;Rj，进程 A 持有 Ri，要请求 Rj，B <span>持有 Ri，要请求 Rj，由于资源顺序不可逆向，则 B 的请求被拒绝，此时剥夺 B 占有资源，A 向下执行</span></li></ul><p data-lake-id=\"f73b4c171ff245709f2d85589bc73772\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>死锁避免</strong></p><p data-lake-id=\"473ac5d58c43f7935040f063a5818ddf\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>资源分配拒绝算法（银行家算法）</strong>，已知当前可分配资源，以及各个进程执行需要的初始最大资源和已分配的资源，此时选择一个可用资源能支持执行完毕的进程，执行完毕；回收所有资源作为当前可用资源，重复，如果出现当前<span>可用资源不能支持任何进程的执行，则称为</span><strong><span>不安全状态——需要某个进程提前释放资源避免死锁</span></strong></p><p data-lake-id=\"5186178697e3b2e5af00ecc0afdc0902\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong><span>死锁检测</span></strong></p><p data-lake-id=\"92bcfc6370d43cb66ebe2fa15852f8b2\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span>使用银行家算法检测当前是否处于安全状态，如果非安全状态，则回滚直到安全状态，或者直接结束死锁进程</span></p><p data-lake-id=\"b7b7aadf45b6f96cc46db614ab8417cd\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><span>死锁与银行家算法细节见下：</span></p><div data-card-type=\"block\" data-lake-card=\"yuque\" id=\"oEkwh\" class=\"lake-card-margin\"><span>此处为语雀文档，点击链接查看：</span><a href=\"https://www.yuque.com/nepjnq/ntyr7v/bgz0x5\" style=\"\n    word-wrap: break-word;\n    color: #096DD9;\n    touch-action: manipulation;\n    background-color: rgba(0,0,0,0);\n    text-decoration: none;\n    outline: none;\n    cursor: pointer;\n    transition: color .3s;\n  \">https://www.yuque.com/nepjnq/ntyr7v/bgz0x5</a></div><p data-lake-id=\"aa38a486fb7314488892ca6dd4698d5b\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p></div>",
  "slug": 29641243,
  "title": "操作系统"
}