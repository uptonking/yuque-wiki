{
  "body_html": "<!doctype html><div class=\"lake-content-editor-core lake-engine lake-typography-classic\" data-lake-element=\"root\" data-selection-undefined=\"%7B%22path%22%3A%5B%5B1%2C0%2C4%5D%2C%5B1%2C0%2C4%5D%5D%2C%22active%22%3Atrue%7D\"><blockquote style=\"margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;\"><ul data-lake-id=\"803705ae68fba3899eda4fc7c6d56b89\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"01cfc141f7c83a22658094580adae233\">以下的 Demo 都基于 Koa2 服务端，跨域通过限定 localhost 下的不同端口模拟</li><li data-lake-id=\"1ad66994f8cd82fab393bb8c2a767545\">运行时本地需安装 node，执行 npm install 安装依赖后执行子目录的 bat 文件即可</li><li data-lake-id=\"93eaceab6984042b5055d6f103b340c0\">完整代码见：<a href=\"https://github.com/NepJNQ/Front-end-Baby/tree/master/network/cross-origin\" target=\"_blank\">https://github.com/NepJNQ/Front-end-Baby/tree/master/network/cross-origin</a></li></ul></blockquote><p data-lake-id=\"69d3e16bbb005e48d5588791064ae347\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">跨域方式</p><ul data-lake-id=\"6e351de018c171a55d1ee18cc157b8b5\" start=\"1\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"71ef0c6e0d816029195d47c647c96eb7\">适合通用场景：CORS、JSONP</li><li data-lake-id=\"536371710c16ac62866ff69743fa60f1\">适合当前窗口与 iframe 窗口通信：location.hash、window.name</li><li data-lake-id=\"7e01dcbcd8e001d8f6365b00d65e6d3d\">适合跨窗口通信：postMessage</li></ul><h3 data-lake-id=\"d8a75dc8bbf3a4cb9fe810dc04dfd555\" id=\"qwDr4\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">CORS</h3><p data-lake-id=\"2f38203ff3ef55250d9420b4ef664e82\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>运行说明：</strong>执行 bat，访问 <span>localhost:3000/index.html 即可</span></p><ul data-lake-id=\"0e15f5876cb12f5c05e31b95e4c5673a\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"cdd4d7ff81ec30e800df64236a4484b8\"><strong>请求</strong><strong><span>端</span></strong><strong>：</strong>运行于 localhost:3000 的请求端通过 ajax 向运行于 <span>localhost:3001 的响应端</span>发送跨域请求</li><li data-lake-id=\"44fb3cedc39e513b7074b05469a74377\"><strong>响应端：</strong>相应时需要设置 header 的 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">Access-Control-Allow-Origin</code> 为请求端域名（设置为 * 时不安全）</li></ul><h3 data-lake-id=\"544d74acecf99e417cf149de7e4406cf\" id=\"ARVM9\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">JSONP</h3><p data-lake-id=\"da632ed1fb22a6266781825927a57e62\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>运行说明：</strong>执行 bat，访问 <span>localhost:3000/index.html 即可</span></p><ul data-lake-id=\"2fb975205ea015d8556a207c0a28968f\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"50f0e680a7bc89a73efed4045368cd93\"><strong><span>请求端：</span></strong><span>点击 button 时，触发</span>动态添加 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">&lt;script&gt;</code>，且令 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">src</code> 为目标域，目标域最后应该携带一个回调函数名称，该回调函数需要在请求端实现</li><li data-lake-id=\"b384ff36113dc050260e0fdb8adedea8\"><strong>响应端：</strong>截取请求中的 callback 字段，拼接要发送的数据，构成 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">callback({... : \"...\"})</code> 的 JS 代码形式作为响应体，请求端收到响应体后，会直接执行回调</li></ul><h3 data-lake-id=\"8ccac0d02dc3b5d27f7741489502853f\" id=\"5XWFZ\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">location.hash + iframe</h3><p data-lake-id=\"2852fce522aa2e1e119c730f372db25f\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>运行说明：</strong>执行 bat，访问 <span>localhost:3000/a.html 即可</span></p><ul data-lake-id=\"6cff1e8a4cd4db28c994d0e3be1373ff\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"97a7248d0ceee2d654dafa3a08e858ef\"><strong><span>请求端(a.html)：</span></strong><span>3000/</span><span>a.html 创建 iframe 指向目标域 </span><span>3001/b</span><span>.html，b 成为 a 的子页面</span></li><li data-lake-id=\"2b6e76b889d953266621bb34666373d8\"><strong><span>响应端(b</span></strong><strong><span>.html)</span></strong><strong><span>：</span></strong><span>3001/b</span><span>.html 再创建 iframe 指向</span><span>目标域 </span><span>3000/c</span><span>.html，在 src 后拼接 hash 字段传递参数</span></li><li data-lake-id=\"5c907d1e08495c6662dfc3f1278d5d61\"><strong><span>中介(c.html)：</span></strong><span>3000/c</span><span>.html 与 </span><span>3000/</span><span>a.html 同源，因此通过 </span><code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\"><span>window.parent.parent</span></code><span> 上溯两级获取到 </span>a.html，修改它的 hash，而 a.html 上的检查函数会察觉到 hash 的变化，获取数据</li></ul><p data-lake-id=\"177bb1d4fe6e507fc7a1054991ad6f77\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>总结：</strong>这种方式以三重页面套娃实现，限于 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">window.parent</code> 可以<strong>跨域读</strong>的特性（具体参考 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#window\" target=\"_blank\">MDN ：跨源脚本 API 访问</a>），b 文档没办法直接通过 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">window.parent.location.hash</code> 修改父页面哈希值，必须通过同源页 c</p><h3 data-lake-id=\"e59e71b00e1170195dd6bd30364bcc4b\" id=\"Xn7Pu\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\"><span>postMessage</span></h3><p data-lake-id=\"40b11ec6a5f4ceb912f2ac2f02cae939\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>运行说明：</strong>执行 bat，访问 <span>localhost:3000/a.html 即可</span></p><ul data-lake-id=\"a87e44aa109eef4df53c912c2d33cb8f\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"f3be3bf0bbb1c803a15b2fac2bc32b27\"><strong><span>请求端(a.html)：</span></strong><span>3000/</span><span>a.html 创建 iframe 指向目标域 </span><span>3001/b</span><span>.html，通过 </span><code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">iframe.contentWindow</code> 获取对目标域窗口的引用，调用其上的 <code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\">postMessage()</code> 方法，向 3001 端口分发消息；同时该窗口开始监听 message 事件，等待跨域的回复</li><li data-lake-id=\"c3e45c6b3aaa1e23e5ca9a7aa7e155f3\"><strong><span>响应端(b</span></strong><strong><span>.html)</span></strong><strong><span>：</span></strong><span>3001/b</span><span>.html 监听 window 上的 message 事件，并通过 </span><code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\"><span>window.parent</span></code><span> 获得父窗口引用，执行该引用的 </span><code style=\"font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;\"><span>postMessage()</span></code><span>，</span><span>向 3000 端口</span><span>分发消息</span></li></ul><p data-lake-id=\"e25e623b119481d215cde47e9720f14d\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong><span>总结：</span></strong><span>当跨域请求方获取对方窗口的引用（</span><span>iframe.contentWindow 只是一种方法</span><span>），即可通过 </span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\" target=\"_blank\"><span>window.postMessage()</span></a><span> 方法传递消息，响应方只需要监听 message 事件即可接收数据，通常建议传入明确的 targetOrigin 保证安全</span></p><h3 data-lake-id=\"e94ce572d665cb0ffaa279a9d937bc88\" id=\"5mrl9\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\"><span>Window.name</span></h3><p data-lake-id=\"e593d0bb6e97afdbd5202d2298c14168\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong>运行说明：</strong>执行 bat，访问 <span>localhost:3000/a.html 即可</span></p><ul data-lake-id=\"4a69be5ee45e2931f682dd4017568981\" lake-indent=\"0\" style=\"list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;\"><li data-lake-id=\"407d5cc08f1daa87111a40f8ca5b81b9\"><strong><span>请求端(a.html)：</span></strong><span>3000/</span><span>a.html 创建 iframe 指向目标域 </span><span>3001/b</span><span>.html，添加对于 iframe 的 load 事件监听；第一次触发时说明已经完成跨域请求，修改 iframe.src 到同源文档 </span>3000/c.html，这样的修改不会改变 window.name；第二次触发时，<span>通过 </span>iframe.contentWindow.name 获取窗口的 name</li><li data-lake-id=\"0a7fafab2cb5486188a067aa71b5d1ab\"><strong><span>响应端(b</span></strong><strong><span>.html)</span></strong><strong><span>：</span></strong><span>3001/b</span><span>.html 直接设置 window.name 为要传递的数据即可</span></li><li data-lake-id=\"08d103cf0f6c2e3daf9efef26e5ceac3\"><strong><span>中介(c.html)：window.name 不会因为新文档的载入而改变</span></strong><span>，由 b 载入 c 时，窗口还是一个，当前窗口名未改变，a 通过 iframe.contentWindow 获得同源文档 c 的窗口引用，即可获取窗口名</span></li></ul><p data-lake-id=\"644dac4a1e633aa592cf193a2028159a\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><strong><span>总结：</span></strong>每个窗口都有自己独立的 window.name，无论重载的文档是否同源，只要窗口未销毁就会保持同一个window.name（别的文档未重写时）；但是 window.name 不支持跨域访问，需要让窗口先后被跨域修改 name，再重载同源文档后才能被最初请求的文档访问。利用 window.name 可以存储不超过2M的 string 数据</p></div>",
  "slug": 30270524,
  "title": "跨域实战"
}