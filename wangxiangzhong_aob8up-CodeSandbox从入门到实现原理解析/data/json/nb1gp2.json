{
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><div class=\"ne-quote\"><p id=\"ub5ddec6d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">本文转自：</span><a href=\"https://segmentfault.com/a/1190000019679430\" data-href=\"https://segmentfault.com/a/1190000019679430\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">CodeSandbox 浏览器端的webpack是如何工作的？ 上篇</span></a></p></div><p id=\"u41be3cc4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">这期来关注一下</span><a href=\"https://link.segmentfault.com/?enc=ICoKptJteMRUHzrl%2BGBEQg%3D%3D.JPMNqZfMO6BrphGSfOJ4VJMqXSh4PlOpx25t%2FKK1H88%3D\" data-href=\"https://link.segmentfault.com/?enc=ICoKptJteMRUHzrl%2BGBEQg%3D%3D.JPMNqZfMO6BrphGSfOJ4VJMqXSh4PlOpx25t%2FKK1H88%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">CodeSandbox</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">, 这是一个浏览器端的沙盒运行环境，支持多种流行的构建模板，例如 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">create-react-app</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">、 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">vue-cli</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">、</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">parcel</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">等等。 可以用于快速原型开发、DEMO 展示、Bug 还原等等。</span></p><p id=\"u4acd073d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u5081bd13\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">相似的产品有很多，例如</span><a href=\"https://codepen.io/pen\" data-href=\"https://codepen.io/pen\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">codepen</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">、</span><a href=\"https://link.segmentfault.com/?enc=VcKM1IEiFYNzLnpsLrh%2BhQ%3D%3D.0Zx1tgTHTBJ21leZ2a8jxEI2yusHXMTqFyhxLnDJTzc%3D\" data-href=\"https://link.segmentfault.com/?enc=VcKM1IEiFYNzLnpsLrh%2BhQ%3D%3D.0Zx1tgTHTBJ21leZ2a8jxEI2yusHXMTqFyhxLnDJTzc%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">JSFiddle</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">、</span><a href=\"https://link.segmentfault.com/?enc=YeoQ0obZ9g3EAb%2BwDIvq6w%3D%3D.kkiucnFBJs5KPSyjJGMNeOYsep4MGiVLArujbwu56Nz%2BgZwGiTvkccLoQtIM%2BqTl\" data-href=\"https://link.segmentfault.com/?enc=YeoQ0obZ9g3EAb%2BwDIvq6w%3D%3D.kkiucnFBJs5KPSyjJGMNeOYsep4MGiVLArujbwu56Nz%2BgZwGiTvkccLoQtIM%2BqTl\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">WebpackBin</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">(已废弃)。</span></p><p id=\"ud5fb4ba0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"ud34f6563\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 则更加强大，可以视作是浏览器端的 Webpack 运行环境, 甚至在 V3 版本已经支持 VsCode 模式，支持 Vscode 的插件和 Vim 模式、还有主题。</span></p><p id=\"u4c37f0dc\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u1dae4372\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">另外 CodeSandbox 支持离线运行(PWA)。基本上可以接近本地 VSCode 的编程体验. 有 iPad 的同学，也可以尝试基于它来进行开发。所以快速的原型开发我一般会直接使用 CodeSandbox。</span></p><p id=\"u4b124872\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"ubea6b5f1\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">目录</span></strong></p><ul class=\"ne-ul\"><li id=\"ua7fd95f2\"><a href=\"https://segmentfault.com/a/1190000019679430#%E5%BC%95\" data-href=\"https://segmentfault.com/a/1190000019679430#%E5%BC%95\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">引</span></a></li><li id=\"ue3499ba3\"><a href=\"https://segmentfault.com/a/1190000019679430#%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\" data-href=\"https://segmentfault.com/a/1190000019679430#%E5%9F%BA%E6%9C%AC%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">基本目录结构</span></a></li><li id=\"u9329de9c\"><a href=\"https://segmentfault.com/a/1190000019679430#%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B\" data-href=\"https://segmentfault.com/a/1190000019679430#%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">项目构建过程</span></a></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u1de18186\"><a href=\"https://segmentfault.com/a/1190000019679430#packager\" data-href=\"https://segmentfault.com/a/1190000019679430#packager\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Packager</span></a></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"ueb3b8101\"><a href=\"https://segmentfault.com/a/1190000019679430#webpackdllplugin\" data-href=\"https://segmentfault.com/a/1190000019679430#webpackdllplugin\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">WebpackDllPlugin</span></a></li><li id=\"u789fd1d6\"><a href=\"https://segmentfault.com/a/1190000019679430#%E5%9C%A8%E7%BA%BF%E6%89%93%E5%8C%85%E6%9C%8D%E5%8A%A1\" data-href=\"https://segmentfault.com/a/1190000019679430#%E5%9C%A8%E7%BA%BF%E6%89%93%E5%8C%85%E6%9C%8D%E5%8A%A1\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">在线打包服务</span></a></li><li id=\"uf86fa5e7\"><a href=\"https://segmentfault.com/a/1190000019679430#%E5%9B%9E%E9%80%80%E6%96%B9%E6%A1%88\" data-href=\"https://segmentfault.com/a/1190000019679430#%E5%9B%9E%E9%80%80%E6%96%B9%E6%A1%88\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">回退方案</span></a></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uf60ddbe5\"><a href=\"https://segmentfault.com/a/1190000019679430#transpilation\" data-href=\"https://segmentfault.com/a/1190000019679430#transpilation\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Transpilation</span></a></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u3bd758e6\"><a href=\"https://segmentfault.com/a/1190000019679430#%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1\" data-href=\"https://segmentfault.com/a/1190000019679430#%E5%9F%BA%E6%9C%AC%E5%AF%B9%E8%B1%A1\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">基本对象</span></a></li><li id=\"u7211ed71\"><a href=\"https://segmentfault.com/a/1190000019679430#manager\" data-href=\"https://segmentfault.com/a/1190000019679430#manager\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Manager</span></a></li><li id=\"u4a817609\"><a href=\"https://segmentfault.com/a/1190000019679430#transpiledmodule\" data-href=\"https://segmentfault.com/a/1190000019679430#transpiledmodule\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">TranspiledModule</span></a></li><li id=\"ub6e4e4a5\"><a href=\"https://segmentfault.com/a/1190000019679430#transpiler\" data-href=\"https://segmentfault.com/a/1190000019679430#transpiler\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Transpiler</span></a></li><li id=\"u0e22d317\"><a href=\"https://segmentfault.com/a/1190000019679430#babeltranspiler\" data-href=\"https://segmentfault.com/a/1190000019679430#babeltranspiler\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">BabelTranspiler</span></a></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u9b932545\"><a href=\"https://segmentfault.com/a/1190000019679430#evaluation\" data-href=\"https://segmentfault.com/a/1190000019679430#evaluation\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Evaluation</span></a></li></ul></ul><ul class=\"ne-ul\"><li id=\"u56a714d8\"><a href=\"https://segmentfault.com/a/1190000019679430#%E6%8A%80%E6%9C%AF%E5%9C%B0%E5%9B%BE\" data-href=\"https://segmentfault.com/a/1190000019679430#%E6%8A%80%E6%9C%AF%E5%9C%B0%E5%9B%BE\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">技术地图</span></a></li><li id=\"u7be87472\"><a href=\"https://segmentfault.com/a/1190000019679430#%E6%89%A9%E5%B1%95\" data-href=\"https://segmentfault.com/a/1190000019679430#%E6%89%A9%E5%B1%95\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">扩展</span></a></li></ul><h2 id=\"Enkuf\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">引</span></h2><p id=\"u3d5004fe\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499661594-a76d2cbb-00cb-46d8-8328-358135cfeff4.png\" width=\"2548\" id=\"ue44de25f\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u17d9f62f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">笔者对 CodeSandbox 的第一印象是这玩意是运行在服务器的吧？ 比如 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">create-react-app</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 要运行起来需要 node 环境，需要通过 npm 安装一大堆依赖，然后通过 Webpack 进行打包，最后运行一个开发服务器才能在浏览器跑起来。</span></p><p id=\"u6932a676\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u60ebdb9c\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">实际上 CodeSandbox 打包和运行并不依赖于服务器, 它是完全在浏览器进行的</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">。大概的结构如下:</span></p><p id=\"u61e5a8ba\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499659193-8c5b5aed-ea14-4ebb-9e93-43812562a0ca.png\" width=\"500\" id=\"uaeec37e2\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><ul class=\"ne-ul\"><li id=\"u2be4b32d\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Editor</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">: 编辑器。主要用于修改文件，CodeSandbox这里集成了 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">VsCode</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">, 文件变动后会通知 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Sandbox</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 进行转译。计划会有文章专门介绍CodeSandbox的编辑器实现</span></li><li id=\"u0160327c\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Sandbox</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">: 代码运行器。</span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Sandbox 在一个单独的 iframe 中运行, 负责代码的转译(Transpiler)和运行(Evalation)</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">. 如最上面的图，左边是Editor，右边是Sandbox</span></li><li id=\"u912c0018\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Packager</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">包管理器。类似于yarn和npm，负责拉取和缓存 npm 依赖</span></li></ul><p id=\"ua4a99838\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u602c1e24\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 的作者 </span><a href=\"https://link.segmentfault.com/?enc=XZpIvIVeQLj4d2CK0%2BvZrA%3D%3D.iHE%2BvbSLaJ6dQ%2Fffs7%2FkpKR04hphiQgr1uDC5lPlQbs%3D\" data-href=\"https://link.segmentfault.com/?enc=XZpIvIVeQLj4d2CK0%2BvZrA%3D%3D.iHE%2BvbSLaJ6dQ%2Fffs7%2FkpKR04hphiQgr1uDC5lPlQbs%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Ives van Hoorne</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 也尝试过将 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Webpack</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 移植到浏览器上运行，因为现在几乎所有的 CLI 都是使用 Webpack 进行构建的，如果能将 Webpack 移植到浏览器上, 可以利用 Webpack 强大的生态系统和转译机制(loader/plugin)，低成本兼容各种 CLI。</span></p><p id=\"u7da1898f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"uff74c953\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">然而 Webpack 太重了😱，压缩过后的大小就得 3.5MB，这还算勉强可以接受吧；更大的问题是要在浏览器端模拟 Node 运行环境，这个成本太高了，得不偿失。</span></p><p id=\"u9a071591\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"ud1e99991\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">所以 CodeSandbox 决定自己造个打包器，这个打包器更轻量，并且针对 CodeSandbox 平台进行优化。比如 CodeSandbox 只关心开发环境的代码构建, 目标就是能跑起来就行了, 跟 Webpack 相比裁剪掉了以下特性:</span></p><ul class=\"ne-ul\"><li id=\"uf3b4794b\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">生产模式. CodeSandbox 只考虑 development 模式，不需要考虑 production一些特性，比如</span></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u035c3385\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">代码压缩，优化</span></li><li id=\"ua87aa3a5\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Tree-shaking</span></li><li id=\"u78941f40\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">性能优化</span></li><li id=\"ue7ea5404\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">代码分割</span></li></ul></ul><ul class=\"ne-ul\"><li id=\"u81c3afd6\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">文件输出. 不需要打包成chunk</span></li><li id=\"u6af2b099\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">服务器通信. Sandbox直接原地转译和运行, 而Webpack 需要和开发服务器建立一个长连接用于接收指令，例如 HMR.</span></li><li id=\"u35dee873\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">静态文件处理(如图片). 这些图片需要上传到 CodeSandbox 的服务器</span></li><li id=\"u22f917be\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">插件机制等等</span></li></ul><p id=\"u9d1fd337\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u900892ac\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">所以可以认为</span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox是一个简化版的Webpack, 且针对浏览器环境进行了优化，比如使用worker来进行并行转译</span></strong></p><p id=\"u6534c41f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 的打包器使用了接近 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Webpack Loader</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 的 API, 这样可以很容易地将 Webpack 的一些 loader 移植过来. 举个例子，下面是 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">create-react-app</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 的实现(查看</span><a href=\"https://link.segmentfault.com/?enc=m%2BMvxFGsxmvgs2Kxdx%2FhhQ%3D%3D.cO%2BRYP2yTmBR5oYDuPTjDuopEp1udiJpW%2BFA96aV3hM02Rt%2B4mF6qLNbTkAKyzvCQphlbx3%2BzCfWv2TdyyKysmsyJE9ykmmjOnInLc3Dru1WglGe9Jyk26HSoo8Btm1eMf1Y1LtDqObwp%2FDRctOnJ4RA%2BRJXGgiEZidWjfAHsCYwe4KHb30X%2B411VwWdON5ZkC8xVPxzYYf4PLrTIhr%2BDKBsn4dX7V7W4qzOAh1we4k%3D\" data-href=\"https://link.segmentfault.com/?enc=m%2BMvxFGsxmvgs2Kxdx%2FhhQ%3D%3D.cO%2BRYP2yTmBR5oYDuPTjDuopEp1udiJpW%2BFA96aV3hM02Rt%2B4mF6qLNbTkAKyzvCQphlbx3%2BzCfWv2TdyyKysmsyJE9ykmmjOnInLc3Dru1WglGe9Jyk26HSoo8Btm1eMf1Y1LtDqObwp%2FDRctOnJ4RA%2BRJXGgiEZidWjfAHsCYwe4KHb30X%2B411VwWdON5ZkC8xVPxzYYf4PLrTIhr%2BDKBsn4dX7V7W4qzOAh1we4k%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">源码</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">)：</span></p><pre data-language=\"javascript\" id=\"syE7S\" class=\"ne-codeblock language-javascript\">import stylesTranspiler from &quot;../../transpilers/style&quot;;\nimport babelTranspiler from &quot;../../transpilers/babe&quot;;\n// ...\nimport sassTranspiler from &quot;../../transpilers/sass&quot;;\n// ...\n\nconst preset = new Preset(\n  &quot;create-react-app&quot;,\n  [&quot;web.js&quot;, &quot;js&quot;, &quot;json&quot;, &quot;web.jsx&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;],\n  {\n    hasDotEnv: true,\n    setup: manager =&gt; {\n      const babelOptions = {\n        /*..*/\n      };\n      preset.registerTranspiler(\n        module =&gt;\n          /\\.(t|j)sx?$/.test(module.path) &amp;&amp; !module.path.endsWith(&quot;.d.ts&quot;),\n        [\n          {\n            transpiler: babelTranspiler,\n            options: babelOptions\n          }\n        ],\n        true\n      );\n      preset.registerTranspiler(\n        module =&gt; /\\.svg$/.test(module.path),\n        [\n          { transpiler: svgrTranspiler },\n          {\n            transpiler: babelTranspiler,\n            options: babelOptions\n          }\n        ],\n        true\n      );\n      // ...\n    }\n  }\n);</pre><p id=\"u821653ab\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">可以看出, CodeSandbox的Preset和Webpack的配置长的差不多.</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">不过, 目前你只能使用 CodeSandbox 预定义的 Preset, 不支持像 Webpack 一样进行配置, 个人觉得这个是符合 CodeSandbox 定位的，这是一个快速的原型开发工具，你还折腾 Webpack 干嘛？</span></strong></p><p id=\"u98d90ece\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></strong></p><p id=\"udd7fa54f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">目前支持这些Preset:</span></p><p id=\"u9c013ea6\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499660429-317a5309-79e7-4914-ab2e-ab7fb57f0970.png\" width=\"917\" id=\"u894f7fd7\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><hr id=\"U2Yj5\" class=\"ne-hr\"><h2 id=\"XilQN\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">基本目录结构</span></h2><p id=\"ua1f4aa70\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 的客户端是开源的，不然就没有本文了，它的基本目录结构如下:</span></p><ul class=\"ne-ul\"><li id=\"u213b5126\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">packages</span></strong></li></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ud6274f8e\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">app</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox应用</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"ufe9e5dbe\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">app</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">编辑器实现</span></li><li id=\"ucae7cc97\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">embed</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">网页内嵌运行 codesandbox</span></li><li id=\"u8270b9f6\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">sandbox</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">运行沙盒，在这里执行代码构建和预览，相当于一个缩略版的 Webpack. 运行在单独的 iframe 中</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"3\" class=\"ne-ul\"><li id=\"u93d4a6c6\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">eval</span></li></ul></ul></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"4\" class=\"ne-ul\"><li id=\"ue224da98\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">preset</span></li></ul></ul></ul></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"5\" class=\"ne-ul\"><li id=\"u0769efb0\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">create-react-app</span></li><li id=\"u5ac5d7f8\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">parcel</span></li><li id=\"ua9a25795\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">vue-cli</span></li><li id=\"u217e0266\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">...</span></li></ul></ul></ul></ul></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"4\" class=\"ne-ul\"><li id=\"u0d73fb11\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">transpiler</span></li></ul></ul></ul></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"5\" class=\"ne-ul\"><li id=\"u76bc50c4\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">babel</span></li><li id=\"u57b445e1\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">sass</span></li><li id=\"u55e8bf06\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">vue</span></li><li id=\"ua5f95204\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">...</span></li></ul></ul></ul></ul></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"3\" class=\"ne-ul\"><li id=\"ua15a486b\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">compile.ts 编译器</span></li></ul></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u27e159e2\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">common</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">放置通用的组件、工具方法、资源</span></li><li id=\"u2115c06e\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">codesandbox-api</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">: 封装了统一的协议，用于 sandbox 和 editor 之间通信(基于postmessage)</span></li><li id=\"u15f4a39f\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">codesandbox-browserfs</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">: 这是一个浏览器端的‘文件系统’，模拟了 NodeJS 的文件系统 API，支持在本地或从多个后端服务中存储或获取文件.</span></li><li id=\"u80a279e3\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">react-sandpack</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">: codesandbox公开的SDK，可以用于自定义自己的codesandbox</span></li></ul></ul><p id=\"u9b82bf6e\" class=\"ne-p\"><a href=\"https://link.segmentfault.com/?enc=9foIA2XLJq9eELHMgbALPw%3D%3D.uT14S02FyWto3Xv4DI4JfJswRt0ssJF663VuTiRfEU%2FBVRZvzRHC6%2BmSiBsXXZssQGryJDrAXCfR%2F3ONimIZgA%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=9foIA2XLJq9eELHMgbALPw%3D%3D.uT14S02FyWto3Xv4DI4JfJswRt0ssJF663VuTiRfEU%2FBVRZvzRHC6%2BmSiBsXXZssQGryJDrAXCfR%2F3ONimIZgA%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">源码在这</span></a></p><hr id=\"PYdtI\" class=\"ne-hr\"><h2 id=\"Xw0UN\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">项目构建过程</span></h2><p id=\"u84a675a0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">packager -&gt; transpilation -&gt; evaluation</span></p><p id=\"u682c4767\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\"></span></p><p id=\"u8c7a0ae9\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Sandbox 构建分为三个阶段:</span></p><ul class=\"ne-ul\"><li id=\"u175f1aa5\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Packager</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">包加载阶段，下载和处理所有npm模块依赖</span></li><li id=\"u563aced3\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Transpilation</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">转译阶段，转译所有变动的代码, 构建模块依赖图</span></li><li id=\"uf8561930\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Evaluation</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">执行阶段，使用</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">eval</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">运行模块代码进行预览</span></li></ul><p id=\"ufd5a967d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">下面会按照上述的步骤来描述其中的技术点。</span></p><h3 id=\"quZIW\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">Packager</span></h3><p id=\"u1587e113\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">尽管 npm 是个'黑洞'，我们还是离不开它。 其实大概分析一下前端项目的 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">node_modules</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">，80%是各种开发依赖组成的。</span></p><p id=\"udf21215d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u2330fd8b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">由于 CodeSandbox 已经包揽了代码构建的部分，所以我们并不需要</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">devDependencies</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">, 也就是说 </span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">在CodeSandbox 中我们只需要安装所有实际代码运行需要的依赖，这可以减少成百上千的依赖下载. 所以暂且不用担心浏览器会扛不住</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">。</span></p><p id=\"uf97f4399\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><h4 id=\"mgJYR\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">WebpackDllPlugin</span></h4><p id=\"u8c8d7558\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 的依赖打包方式受 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">WebpackDllPlugin</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 启发，DllPlugin 会将所有依赖都打包到一个</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">dll</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">文件中，并创建一个 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">manifest</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> 文件来描述dll的元数据(如下图)。</span></p><p id=\"u27ef72cd\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u8173f82a\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Webpack 转译时或者 运行时可以根据 manifest 中的模块索引(例如</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">__webpack_require__('../node_modules/react/index.js')</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">)来加载 dll 中的模块。 因为</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">WebpackDllPlugin</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">是在运行或转译之前预先对依赖的进行转译，所以在项目代码转译阶段可以忽略掉这部分依赖代码，这样可以提高构建的速度(真实场景对npm依赖进行Dll打包提速效果并不大):</span></p><p id=\"uaa983d53\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499659207-a854a32c-8117-4cce-b6be-8e0e9fd4bc12.png\" width=\"713\" id=\"ueddeeeba\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u57107c22\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">manifest文件</span></p><p id=\"u4839857d\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499660430-19aaa03a-c4c5-4f45-a2c4-3510f9e3e659.png\" width=\"1074\" id=\"u7b435043\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><h4 id=\"dDQuM\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">在线打包服务</span></h4><p id=\"u6e7b39f7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">基于这个思想, CodeSandbox 构建了自己的在线打包服务, 和WebpackDllPlugin不一样的是，CodeSandbox是在服务端预先构建Manifest文件的, 而且不区分Dll和manifest文件。 具体思路如下:</span></p><p id=\"ufce36f8b\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499660789-1fe278f9-4492-4c1d-b3c8-a61beab36881.png\" width=\"790\" id=\"udf312959\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"uacc7eb5b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">简而言之，CodeSandbox 客户端拿到</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">package.json</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">之后，将</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">dependencies</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">转换为一个由依赖和版本号组成的</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Combination</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">(标识符, 例如 </span><a href=\"https://link.segmentfault.com/?enc=VDVnQt8Px80atWCM%2BCs6%2FQ%3D%3D.gJRwGqCYQagsyeFVcSl74rkVlzdIu5rxjX6E4nTbA6aHBeGhv6%2BrPxUiA%2FOHScmCyd7QVQIF5d45mtIrtlRkAnWH3AlnyAf1G4OBMS0nHalk%2BI7Y6HVCj2hb2OM6d2Z6EX0Uul43fMX9P1XWOn1mvx8MqzKOaPKWecHMRx7K1v4re8QYmeY69BzjTnmUUrcFs3Lz1c3vxHszrsqYB5AcJnEo59%2FS2cUulk6l3j%2BWN4XUicwABPpiMVfqwH8Urr0x5KIHk9bwwwwVuu2MVqC%2BFA%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=VDVnQt8Px80atWCM%2BCs6%2FQ%3D%3D.gJRwGqCYQagsyeFVcSl74rkVlzdIu5rxjX6E4nTbA6aHBeGhv6%2BrPxUiA%2FOHScmCyd7QVQIF5d45mtIrtlRkAnWH3AlnyAf1G4OBMS0nHalk%2BI7Y6HVCj2hb2OM6d2Z6EX0Uul43fMX9P1XWOn1mvx8MqzKOaPKWecHMRx7K1v4re8QYmeY69BzjTnmUUrcFs3Lz1c3vxHszrsqYB5AcJnEo59%2FS2cUulk6l3j%2BWN4XUicwABPpiMVfqwH8Urr0x5KIHk9bwwwwVuu2MVqC%2BFA%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">v1/combinations/babel-runtime@7.3.1&amp;csbbust@1.0.0&amp;react@16.8.4&amp;react-dom@16.8.4&amp;react-router@5.0.1&amp;react-router-dom@5.0.1&amp;react-split-pane@0.1.87.json</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">), 再拿这个 Combination 到服务器请求。服务器会根据 Combination 作为缓存键来缓存打包结果，如果没有命中缓存，则进行打包。</span></p><p id=\"u15dc2a12\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u22829ef6\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">打包实际上还是使用</span></strong><strong><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">yarn</span></strong><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">来下载所有依赖，只不过这里为了剔除 npm 模块中多余的文件，服务端还遍历了所有依赖的入口文件(package.json#main), 解析 AST 中的 require 语句，递归解析被 require 模块. 最终形成一个依赖图, 只保留必要的文件</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">。</span></p><p id=\"u2ce8a7f0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u303e7eee\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">最终输出 Manifest 文件，它的结构大概如下, 他就相当于WebpackDllPlugin的dll.js+manifest.json的结合体:</span></p><pre data-language=\"json\" id=\"V1R7x\" class=\"ne-codeblock language-json\">{\n  // 模块内容\n  &quot;contents&quot;: {\n    &quot;/node_modules/react/index.js&quot;: {\n      &quot;content&quot;: &quot;'use strict';↵↵if ....&quot;, // 代码内容\n      &quot;requires&quot;: [                        // 依赖的其他模块\n        &quot;./cjs/react.development.js&quot;,\n      ],\n    },\n    &quot;/node_modules/react-dom/index.js&quot;: {/*..*/},\n    &quot;/node_modules/react/package.json&quot;: {/*...*/},\n    //...\n  },\n  // 模块具体安装版本号\n  &quot;dependencies&quot;: [{name: &quot;@babel/runtime&quot;, version: &quot;7.3.1&quot;}, {name: &quot;csbbust&quot;, version: &quot;1.0.0&quot;},/*…*/],\n  // 模块别名, 比如将react作为preact-compat的别名\n  &quot;dependencyAliases&quot;: {},\n  // 依赖的依赖, 即间接依赖信息. 这些信息可以从yarn.lock获取\n  &quot;dependencyDependencies&quot;: {\n    &quot;object-assign&quot;: {\n      &quot;entries&quot;: [&quot;object-assign&quot;], // 模块入口\n      &quot;parents&quot;: [&quot;react&quot;, &quot;prop-types&quot;, &quot;scheduler&quot;, &quot;react-dom&quot;], // 父模块\n      &quot;resolved&quot;: &quot;4.1.1&quot;,\n      &quot;semver&quot;: &quot;^4.1.1&quot;,\n    }\n    //...\n  }\n}</pre><p id=\"u962e84a2\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></strong></p><p id=\"u0b3207a1\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Serverless 思想</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"><br />值得一提的是 CodeSandbox 的 Packager 后端使用了 Serverless(基于 AWS Lambda)，基于 Serverless 的架构让 Packager 服务更具伸缩性，可以灵活地应付高并发的场景。使用 Serverless 之后 Packager 的响应时间显著提高，而且费用也下去了。</span></p><p id=\"uf2271a82\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u8e609ef7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Packager 也是开源的, </span><a href=\"https://link.segmentfault.com/?enc=tlqnBJFH3Xy6XBoynTBoVA%3D%3D.kxqOlNsdhVIlrfwFuglT0fGVGeMV9nJn2rfr1pC6RVScCz%2BFylbe%2FwGQqNHghD7iW0fIcFTQi4nl0C7DPeVtFw%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=tlqnBJFH3Xy6XBoynTBoVA%3D%3D.kxqOlNsdhVIlrfwFuglT0fGVGeMV9nJn2rfr1pC6RVScCz%2BFylbe%2FwGQqNHghD7iW0fIcFTQi4nl0C7DPeVtFw%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">点此围观</span></a><span class=\"ne-text\">。</span></p><p id=\"ua34cc9ca\" class=\"ne-p\"><span class=\"ne-text\"></span></p><h4 id=\"MvRNw\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">回退方案</span></h4><p id=\"u905d8aae\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">AWS Lambda函数是有局限性的, 比如</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">/tmp</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">最多只能有 500MB 的空间. 尽管大部分依赖打包场景不会超过这个限额, 为了增强可靠性(比如上述的方案可能出错，也可能漏掉一些模块), Packager还有回退方案.</span></p><p id=\"u953fc55b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">后来CodeSanbox作者开发了新的Sandbox，支持把包管理的步骤放置到浏览器端, 和上面的打包方式结合着使用。原理也比较简单: </span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">在转译一个模块时，如果发现模块依赖的npm模块未找到，则惰性从远程下载回来</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">. 来看看它是怎么处理的：</span></p><p id=\"u32155014\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499660794-40048b5f-4839-44bc-a451-d665ad6559b2.png\" width=\"896\" id=\"ub2338500\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u7d1d1bfe\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">在回退方案中CodeSandbox 并不会将 package.json 中所有的包都下载下来，而是在模块查找失败时，惰性的去加载。比如在转译入口文件时，发现 react 这个模块没有在本地缓存模块队列中，这时候就会到远程将它下载回来，然后接着转译。</span></p><p id=\"u151532cf\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"ubae4cb88\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">也就是说，因为在转译阶段会静态分析模块的依赖，只需要将真正依赖的文件下载回来，而不需要将整个npm包下载回来，节省了网络传输的成本。</span></p><p id=\"u54595ba6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"udc93569e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 通过</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">unpkg.com</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">或</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">cdn.jsdelivr.net</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">来获取模块的信息以及下载文件, 例如</span></p><ul class=\"ne-ul\"><li id=\"ueb7ad1d9\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">获取 package.json:</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">https://unpkg.com/react@latest/package.json</span></li><li id=\"u2e98aef2\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">包目录结构获取:</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">https://unpkg.com/antd@3.17.0/?meta</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">这个会递归返回该包的所有目录信息</span></li><li id=\"ua2dd6488\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">具体文件下载:</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">https://unpkg.com/react@16.8.6/cjs/react.production.min.js</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">或者</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">https://cdn.jsdelivr.net/npm/@babel/runtime@7.3.1/helpers/interopRequireDefault.js</span></li></ul><hr id=\"dYyLH\" class=\"ne-hr\"><h3 id=\"qvAUm\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">Transpilation</span></h3><p id=\"uc69724a7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">讲完 Packager 现在来看一下 Transpilation, 这个阶段</span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">从应用的入口文件开始, 对源代码进行转译, 解析AST，找出下级依赖模块，然后递归转译，最终形成一个'依赖图'</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">:</span></p><p id=\"ucf870916\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499661807-d91e1bd8-c969-4638-ac9e-f55f89126733.png\" width=\"1087\" id=\"u38a2dfa0\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"ub780d551\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">CodeSandbox 的整个转译器是在一个单独的 iframe 中运行的：</span></p><p id=\"u712bf81c\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499662169-da93d0ce-13ce-4c6a-914f-4d57f87ca936.png\" width=\"500\" id=\"u64b1f676\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u425db554\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Editor 负责变更源代码，源代码变更会通过 postmessage 传递给 Compiler，这里面会携带 </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Module+template</span><span class=\"ne-text\" style=\"font-size: 16px\">：</span></p><ul class=\"ne-ul\"><li id=\"u0640c6c4\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Module</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">中包含所有源代码内容和模块路径，其中还包含 package.json, Compiler 会根据 package.json 来读取 npm 依赖;</span></li><li id=\"u81b50593\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">template</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">表示 Compiler 的 Preset，例如</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">create-react-app</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">、</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">vue-cli</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">, 定义了一些 loader 规则，用来转译不同类型的文件, 另外preset也决定了应用的模板和入口文件。 通过上文我们知道, 这些 template 目前的预定义的.</span></li></ul><h4 id=\"GKNap\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">基本对象</span></h4><p id=\"u111469e4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">在详细介绍 Transpilation 之前先大概看一些基本对象，了解这些对象之间的关系：</span></p><p id=\"ud1b4d583\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499662183-fccaa1d1-f4c6-489c-b0d2-caeebd719e9a.png\" width=\"975\" id=\"u04bf1a85\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><ul class=\"ne-ul\"><li id=\"u520cc11c\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Manager</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">这是 Sandbox 的核心对象，负责管理配置信息(Preset)、项目依赖(Manifest)、以及维护项目所有模块(TranspilerModule)</span></li><li id=\"u121d29c6\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Manifest</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">通过上文的 Packager 我们知道，Manifest 维护所有依赖的 npm 模块信息</span></li><li id=\"u7c543495\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">TranspiledModule</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">表示模块本身。这里面维护转译的结果、代码执行的结果、依赖的模块信息，负责驱动具体模块的转译(调用 Transpiler)和执行</span></li><li id=\"u4517cf44\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Preset</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">一个项目构建模板，例如</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">vue-cli</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">、</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">create-react-app</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">. 配置了项目文件的转译规则, 以及应用的目录结构(入口文件)</span></li><li id=\"u39d07e09\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Transpiler</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">等价于 Webpack 的 loader，负责对指定类型的文件进行转译。例如 babel、typescript、pug、sass 等等</span></li><li id=\"ufd7635dc\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">WorkerTranspiler</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">这是 Transpiler 的子类，调度一个 Worker池来执行转译任务，从而提高转译的性能</span></li></ul><h4 id=\"jM9CJ\"></h4><h4 id=\"hWrU6\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">Manager</span></h4><p id=\"ucea45415\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Manager是一个管理者的角色，从大局上把控整个转译和执行的流程. 现在来看看整体的转译流程：</span></p><p id=\"u8a77fc05\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499662498-3ee66f2b-36e9-4d0e-a9b4-c3265b0fbd67.png\" width=\"1189\" id=\"u0d3784d5\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u98146606\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">大局上基本上可以划分为以下四个阶段:</span></p><ul class=\"ne-ul\"><li id=\"ufac8011e\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">配置阶段</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">：配置阶段会创建 Preset 对象，确定入口文件等等. CodeSandbox 目前只支持限定的几种应用模板，例如 vue-cli、create-react-app。不同模板之间目录结构的约定是不一样的，例如入口文件和 html 模板文件。另外文件处理的规则也不一样，比如 vue-cli 需要处理</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">.vue</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">文件。</span></li><li id=\"ud73b6f8d\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">依赖下载阶段</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">： 即 Packager 阶段，下载项目的所有依赖，生成 Manifest 对象</span></li><li id=\"u404739d6\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">变动计算阶段</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">：根据 Editor 传递过来的源代码，计算新增、更新、移除的模块。</span></li><li id=\"ue8cff90e\"><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">转译阶段</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">：真正开始转译了，首先重新转译上个阶段计算出来的需要更新的模块。接着从入口文件作为出发点，转译和构建新的依赖图。这里不会重复转译没有变化的模块以及其子模块</span></li></ul><h4 id=\"IWBtu\"></h4><h4 id=\"pFskY\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">TranspiledModule</span></h4><p id=\"uaa000b67\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">TranspiledModule用于管理某个具体的模块，这里面会维护转译和运行的结果、模块的依赖信息，并驱动模块的转译和执行：</span></p><p id=\"u46be662d\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499663058-20ebd28d-b07d-433d-b691-6e9f62515655.png\" width=\"1138\" id=\"u260482d4\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u4c453fd9\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">TranspiledModule 会从Preset中获取匹配当前模块的Transpiler列表的，遍历Transpiler对源代码进行转译，转译的过程中会解析AST，分析模块导入语句, 收集新的依赖; 当模块转译完成后，会递归转译依赖列表。 来看看大概的代码：</span></p><pre data-language=\"javascript\" id=\"y2o9h\" class=\"ne-codeblock language-javascript\">  async transpile(manager: Manager) {\n    // 已转译\n    if (this.source)  return this\n    // 避免重复转译, 一个模块只转译一次\n    if (manager.transpileJobs[this.getId()]) return this;\n    manager.transpileJobs[this.getId()] = true;\n\n    // ...重置状态 \n\n    // 🔴从Preset获取Transpiler列表\n    const transpilers = manager.preset.getLoaders(this.module, this.query);\n\n    // 🔴 链式调用Transpiler\n    for (let i = 0; i &lt; transpilers.length; i += 1) {\n      const transpilerConfig = transpilers[i];\n      // 🔴构建LoaderContext，见下文\n      const loaderContext = this.getLoaderContext(\n        manager,\n        transpilerConfig.options || {}\n      );\n\n      // 🔴调用Transpiler转译源代码\n      const {\n        transpiledCode,\n        sourceMap,\n      } = await transpilerConfig.transpiler.transpile(code, loaderContext); // eslint-disable-line no-await-in-loop\n\n      if (this.errors.length) {\n        throw this.errors[0];\n      }\n    }\n\n    this.logWarnings();\n\n    // ...\n\n    await Promise.all(\n      this.asyncDependencies.map(async p =&gt; {\n        try {\n          const tModule = await p;\n          this.dependencies.add(tModule);\n          tModule.initiators.add(this);\n        } catch (e) {\n          /* let this handle at evaluation */\n        }\n      })\n    );\n    this.asyncDependencies = [];\n\n    // 🔴递归转译依赖的模块\n    await Promise.all(\n      flattenDeep([\n        ...Array.from(this.transpilationInitiators).map(t =&gt;\n          t.transpile(manager)\n        ),\n        ...Array.from(this.dependencies).map(t =&gt; t.transpile(manager)),\n      ])\n    );\n\n    return this;\n  }</pre><h4 id=\"gYB8P\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">Transpiler</span></h4><p id=\"u03148c88\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Transpiler等价于webpack的loader，它配置方式以及基本API也和webpack(查看</span><a href=\"https://link.segmentfault.com/?enc=l0MCrRFpveVxQa1VMAI15g%3D%3D.IYtvG7VoMslcgu44pGZdljm5WhNmnExp%2BvY3Ozzg%2FkrYdUQ%2FGIe9B7QlNn5hz3Qj\" data-href=\"https://link.segmentfault.com/?enc=l0MCrRFpveVxQa1VMAI15g%3D%3D.IYtvG7VoMslcgu44pGZdljm5WhNmnExp%2BvY3Ozzg%2FkrYdUQ%2FGIe9B7QlNn5hz3Qj\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">webpack的loader API</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">)大概保持一致，比如链式转译和loader-context. 来看一下Transpiler的基本定义：</span></p><pre data-language=\"javascript\" id=\"pGef5\" class=\"ne-codeblock language-javascript\">export default abstract class Transpiler {\n  initialize() {}\n\n  dispose() {}\n\n  cleanModule(loaderContext: LoaderContext) {}\n\n  // 🔴 代码转换\n  transpile(\n    code: string,\n    loaderContext: LoaderContext\n  ): Promise&lt;TranspilerResult&gt; {\n    return this.doTranspilation(code, loaderContext);\n  }\n\n  // 🔴 抽象方法，由具体子类实现\n  abstract doTranspilation(\n    code: string,\n    loaderContext: LoaderContext\n  ): Promise&lt;TranspilerResult&gt;;\n\n  // ...\n}</pre><p id=\"ucea0706d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Transpiler的接口很简单，</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">transpile</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">接受两个参数:</span></p><ul class=\"ne-ul\"><li id=\"u42b2100d\"><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">code</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">即源代码.</span></li><li id=\"u7fce3755\"><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">loaderContext</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">由TranspiledModule提供, 可以用来访问一下转译上下文信息，比如Transpiler的配置、 模块查找、注册依赖等等。大概外形如下:</span></li></ul><pre data-language=\"javascript\" id=\"kQcOE\" class=\"ne-codeblock language-javascript\">export type LoaderContext = {\n  // 🔴 信息报告\n  emitWarning: (warning: WarningStructure) =&gt; void;\n  emitError: (error: Error) =&gt; void;\n  emitModule: (title: string, code: string, currentPath?: string, overwrite?: boolean, isChild?: boolean) =&gt; TranspiledModule;\n  emitFile: (name: string, content: string, sourceMap: SourceMap) =&gt; void;\n  // 🔴 配置信息\n  options: {\n    context: string;\n    config?: object;\n    [key: string]: any;\n  };\n  sourceMap: boolean;\n  target: string;\n  path: string;\n  addTranspilationDependency: (depPath: string, options?: { isAbsolute?: boolean; isEntry?: boolean; }) =&gt; void;\n  resolveTranspiledModule: ( depPath: string, options?: { isAbsolute?: boolean; ignoredExtensions?: Array&lt;string&gt;; }) =&gt; TranspiledModule;\n  resolveTranspiledModuleAsync: ( depPath: string, options?: { isAbsolute?: boolean; ignoredExtensions?: Array&lt;string&gt;; }) =&gt; Promise&lt;TranspiledModule&gt;;\n    // 🔴 依赖收集\n  addDependency: ( depPath: string, options?: { isAbsolute?: boolean; isEntry?: boolean; }) =&gt; void;\n  addDependenciesInDirectory: ( depPath: string, options?: { isAbsolute?: boolean; isEntry?: boolean; }) =&gt; void;\n  _module: TranspiledModule;\n};</pre><p id=\"uc3d315de\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">先从简单的开始，来看看JSON模块的Transpiler实现, 每个Transpiler子类需要实现doTranspilation，接收源代码，并异步返回处理结果：</span></p><pre data-language=\"javascript\" id=\"RcjuD\" class=\"ne-codeblock language-javascript\">class JSONTranspiler extends Transpiler {\n  doTranspilation(code: string) {\n    const result = `\n      module.exports = JSON.parse(${JSON.stringify(code || '')})\n    `;\n\n    return Promise.resolve({\n      transpiledCode: result,\n    });\n  }\n}</pre><h4 id=\"FUctA\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">BabelTranspiler</span></h4><p id=\"u692e9d13\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">并不是所有模块都像JSON这么简单，比如Typescript和Babel。 为了提高转译的效率，Codesandbox会利用Worker来进行多进程转译，多Worker的调度工作由</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">WorkerTranspiler</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">完成，这是Transpiler的子类，维护了一个Worker池。Babel、Typescript、Sass这类复杂的转译任务都是基于WorkerTranspiler实现的：</span></p><p id=\"u5ded63f7\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499662982-3305e9c4-9a57-4508-8c81-ecb0edd3ded2.png\" width=\"470\" id=\"uf64fed1d\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u8f66fb9e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">其中比较典型的实现是BabelTranspiler, 在Sandbox启动时就会预先fork三个worker，来提高转译启动的速度, BabelTranspiler会优先使用这三个worker来初始化Worker池：</span></p><pre data-language=\"javascript\" id=\"lgPuC\" class=\"ne-codeblock language-javascript\">// 使用worker-loader fork三个loader，用于处理babel编译\nimport BabelWorker from 'worker-loader?publicPath=/&amp;name=babel-transpiler.[hash:8].worker.js!./eval/transpilers/babel/worker/index.js';\n\nwindow.babelworkers = [];\nfor (let i = 0; i &lt; 3; i++) {\n  window.babelworkers.push(new BabelWorker());\n}</pre><p id=\"u5acead63\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">这里面使用到了webpack的</span><a href=\"https://link.segmentfault.com/?enc=HKbJX9fMDp85UkpRqGWP5Q%3D%3D.A%2Bd6lDRcPjGS2lOs8RtC9LBRCNWN0KkwXGTsfB%2BJfmSY2wCopmZC10ZzF8Z%2BUFMqV9U5P7h2V%2FmavsVh8Soqkg%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=HKbJX9fMDp85UkpRqGWP5Q%3D%3D.A%2Bd6lDRcPjGS2lOs8RtC9LBRCNWN0KkwXGTsfB%2BJfmSY2wCopmZC10ZzF8Z%2BUFMqV9U5P7h2V%2FmavsVh8Soqkg%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">worker-loader</span></a><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">, 将指定模块封装为 Worker 对象。让 Worker 更容易使用:</span></p><pre data-language=\"javascript\" id=\"x0qPz\" class=\"ne-codeblock language-javascript\">// App.js\nimport Worker from &quot;./file.worker.js&quot;;\n\nconst worker = new Worker();\n\nworker.postMessage({ a: 1 });\nworker.onmessage = function(event) {};\n\nworker.addEventListener(&quot;message&quot;, function(event) {});</pre><p id=\"ub4e2604c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">BabelTranpiler具体的流程如下:</span></p><p id=\"ub0cfcbbc\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499663475-6bc67b6a-c2fe-46cd-9b2a-e1a5d60d8583.png\" width=\"1544\" id=\"ua801698d\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u27628941\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">WorkerTranspiler会维护</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">空闲的Worker队列</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">和一个</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">任务队列</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">, 它的工作就是驱动Worker来消费任务队列。具体的转译工作在Worker中进行：</span></p><p id=\"u1a76e439\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499664000-6bf7571e-21ac-4950-bc85-efae84e2612c.png\" width=\"877\" id=\"ue55fca30\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><hr id=\"ArIKd\" class=\"ne-hr\"><h3 id=\"XuMDn\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">Evaluation</span></h3><p id=\"ubdf5cb8c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">虽然称为打包器(bundler), 但是 CodeSandbox 并不会进行打包，也就是说他不会像 Webpack 一样，将所有的模块都打包合并成 chunks 文件。</span></p><p id=\"u4a41a460\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u8f9fabc4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Transpilation</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">从</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">入口文件</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">开始转译, 再分析文件的模块导入规则，递归转译依赖的模块. 到</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">Evaluation</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">阶段，CodeSandbox 已经构建出了一个完整的</span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">依赖图</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">. 现在要把应用跑起来了🏃</span></p><p id=\"u4a59fc1b\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499664056-1bcadf5b-0b11-41c8-8a41-227337fc956e.png\" width=\"671\" id=\"uf4c721f4\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><p id=\"u21d97e5d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Evaluation 的原理也比较简单，和 Transpilation 一样，也是从入口文件开始:</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"> </span><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">使用</span></strong><strong><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">eval</span></strong><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">执行入口文件，如果执行过程中调用了</span></strong><strong><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">require</span></strong><strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">，则递归 eval 被依赖的模块</span></strong><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">。</span></p><p id=\"u882fbfbc\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></span></p><p id=\"u8cb57967\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">如果你了解过 Node 的模块导入原理，你可以很容易理解这个过程：</span></p><p id=\"u38b34318\" class=\"ne-p\"><img src=\"https://cdn.nlark.com/yuque/0/2022/png/88655/1649499664591-a02ad079-3234-4bde-9d2d-e36c8ae7f71d.png\" width=\"879\" id=\"u17917756\" class=\"ne-image\" style=\"color: rgb(33, 37, 41); font-size: 16px\"></p><ul class=\"ne-ul\"><li id=\"u1f35f544\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">① 首先要初始化 html，找到</span><span class=\"ne-text\" style=\"color: rgb(214, 51, 132); font-size: 16px\">index.html</span><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">文件，将 document.body.innerHTML 设置为 html 模板的 body 内容.</span></li><li id=\"u658665ba\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">② 注入外部资源。用户可以自定义一些外部静态文件，例如 css 和 js，这些需要 append 到 head 中</span></li><li id=\"u7ac784d4\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">③ evaluate 入口模块</span></li><li id=\"uf79f0711\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">④ 所有模块都会被转译成 CommonJS 模块规范。所以需要模拟这个模块环境。大概看一下代码:</span></li></ul><pre data-language=\"javascript\" id=\"ycShk\" class=\"ne-codeblock language-javascript\">// 实现require方法\nfunction require(path: string) {\n  // ... 拦截一些特殊模块\n\n  // 在Manager对象中查找模块\n  const requiredTranspiledModule = manager.resolveTranspiledModule(\n    path,\n    localModule.path\n  );\n\n  // 模块缓存, 如果存在缓存则说明不需要重新执行\n  const cache = requiredTranspiledModule.compilation;\n\n  return cache\n    ? cache.exports\n    : // 🔴递归evaluate\n      manager.evaluateTranspiledModule(\n        requiredTranspiledModule,\n        transpiledModule\n      );\n}\n\n// 实现require.resolve\nrequire.resolve = function resolve(path: string) {\n  return manager.resolveModule(path, localModule.path).path;\n};\n\n// 模拟一些全局变量\nconst globals = {};\nglobals.__dirname = pathUtils.dirname(this.module.path);\nglobals.__filename = this.module.path;\n\n// 🔴放置执行结果，即CommonJS的module对象\nthis.compilation = {\n  id: this.getId(),\n  exports: {}\n};\n\n// 🔴eval\nconst exports = evaluate(\n  this.source.compiledCode,\n  require,\n  this.compilation,\n  manager.envVariables,\n  globals\n);</pre><ul class=\"ne-ul\"><li id=\"uc4e05930\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">⑤ 使用 eval 来执行模块。同样看看代码：</span></li></ul><pre data-language=\"javascript\" id=\"PiC2C\" class=\"ne-codeblock language-javascript\">export default function(code, require, module, env = {}, globals = {}) {\n  const exports = module.exports;\n  const global = g;\n  const process = buildProcess(env);\n  g.global = global;\n  const allGlobals = {\n    require,\n    module,\n    exports,\n    process,\n    setImmediate: requestFrame,\n    global,\n    ...globals\n  };\n\n  const allGlobalKeys = Object.keys(allGlobals);\n  const globalsCode = allGlobalKeys.length ? allGlobalKeys.join(&quot;, &quot;) : &quot;&quot;;\n  const globalsValues = allGlobalKeys.map(k =&gt; allGlobals[k]);\n  // 🔴将代码封装到一个函数下面，全局变量以函数形式传入\n  const newCode = `(function evaluate(` + globalsCode + `) {` + code + `\\n})`;\n  (0, eval)(newCode).apply(this, globalsValues);\n\n  return module.exports;\n}</pre><p id=\"ub922c9f7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">Ok！到这里 Evaluation 就解释完了，实际的代码比这里要复杂得多，比如 HMR(hot module replacement)支持, 有兴趣的读者，可以自己去看 CodeSandbox 的源码。</span></p><hr id=\"jdpjD\" class=\"ne-hr\"><h2 id=\"eCQDx\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">技术地图</span></h2><p id=\"u54649fa6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">一不小心又写了一篇长文，要把这么复杂代码讲清楚真是一个挑战：</span></p><ul class=\"ne-ul\"><li id=\"u9bb9aa14\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">worker-loader: 将指定模块封装为Worker</span></li><li id=\"uf85fba36\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">babel: JavaScript代码转译，支持ES, Flow, Typescript</span></li><li id=\"u84435a71\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">browserfs: 在浏览器中模拟Node环境</span></li><li id=\"u21d822ab\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">localForage: 客户端存储库，优先使用(IndexedDB or WebSQL)这些异步存储方案，提供类LocalStorage的接口</span></li><li id=\"ue2b9cde8\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41); font-size: 16px\">lru-cache: least-recently-used缓存</span></li></ul><h2 id=\"iz1eJ\"><span class=\"ne-text\" style=\"color: rgb(33, 37, 41)\">扩展</span></h2><ul class=\"ne-ul\"><li id=\"u9be7cc2a\"><a href=\"https://link.segmentfault.com/?enc=RgDauD5SBMo0dqrAk%2FcKvQ%3D%3D.B3HkLZIweY90mH0lRXT1kL3kf1o79yNOVcVmuh7kX4lqDEZYfZe8t7QXtnKZaH49bSQrp3hWPGc57%2BJFgS7tu9oSaAbcrdsF4vuvX6wWKL166J50mssxZqd8FJm%2BdwNzMy8daGnpw%2FpCoX%2FrmtJYJw%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=RgDauD5SBMo0dqrAk%2FcKvQ%3D%3D.B3HkLZIweY90mH0lRXT1kL3kf1o79yNOVcVmuh7kX4lqDEZYfZe8t7QXtnKZaH49bSQrp3hWPGc57%2BJFgS7tu9oSaAbcrdsF4vuvX6wWKL166J50mssxZqd8FJm%2BdwNzMy8daGnpw%2FpCoX%2FrmtJYJw%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">Creating a parallel, offline, extensible, browser based bundler for CodeSandbox</span></a></li><li id=\"u5b084fae\"><a href=\"https://link.segmentfault.com/?enc=hiSzLYWZ5eWG0eLyeHtjZA%3D%3D.SFzFkgv5sILWXwReL%2B%2BZVq8Upi54LD0i1USf12IRtAHxV8dAro9RQpVmFOD7DaGJ\" data-href=\"https://link.segmentfault.com/?enc=hiSzLYWZ5eWG0eLyeHtjZA%3D%3D.SFzFkgv5sILWXwReL%2B%2BZVq8Upi54LD0i1USf12IRtAHxV8dAro9RQpVmFOD7DaGJ\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">year of CodeSandbox - Ives van Hoorne aka @CompuIves at @ReactEurope 2018</span></a></li><li id=\"u9e1ff9dc\"><a href=\"https://link.segmentfault.com/?enc=YPK1f3PuIxNOtkdxyIVo9A%3D%3D.lgjGTMaMmp%2BE12UhbgE9HjHN1GbAt0zQp4%2FM%2FmT8EzsidBU%2FfU0tW3OQKsumN4BWByJ3DBKAv1BAVfMNwmtuf7YwqHOo4G37zZob%2F8mJIH09Us6cSV%2BR8MuKmIVy0A%2BhWvYZM2byh6cv27FkDQvz5w%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=YPK1f3PuIxNOtkdxyIVo9A%3D%3D.lgjGTMaMmp%2BE12UhbgE9HjHN1GbAt0zQp4%2FM%2FmT8EzsidBU%2FfU0tW3OQKsumN4BWByJ3DBKAv1BAVfMNwmtuf7YwqHOo4G37zZob%2F8mJIH09Us6cSV%2BR8MuKmIVy0A%2BhWvYZM2byh6cv27FkDQvz5w%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">How we make npm packages work in the browser</span></a></li><li id=\"u118681b2\"><a href=\"https://link.segmentfault.com/?enc=mnDg0EXm0Rromc3PeWhT%2Fw%3D%3D.B6g07WQGDl5eCIbp6bq7Odf%2BgNCsSHh%2BW2NwvKVGcMSMVqbLsf8s0jAizoG3ed0KW%2FjnOjvWsfRmyNdHIMb4kA%3D%3D\" data-href=\"https://link.segmentfault.com/?enc=mnDg0EXm0Rromc3PeWhT%2Fw%3D%3D.B6g07WQGDl5eCIbp6bq7Odf%2BgNCsSHh%2BW2NwvKVGcMSMVqbLsf8s0jAizoG3ed0KW%2FjnOjvWsfRmyNdHIMb4kA%3D%3D\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">codesandbox/dependency-packager</span></a></li></ul></div>",
  "slug": 72833731,
  "title": "CodeSandbox浏览器端的webpack是如何工作的？"
}